use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn parse_hex_u32(val: &str) -> Option<u32> {
    let trimmed = val.trim();
    if let Some(stripped) = trimmed.strip_prefix("0x").or_else(|| trimmed.strip_prefix("0X")) {
        u32::from_str_radix(stripped, 16).ok()
    } else {
        trimmed.parse::<u32>().ok()
    }
}

fn read_info_file(path: &Path) -> Option<(u32, u32)> {
    let txt = fs::read_to_string(path).ok()?;
    let mut app_start = None;
    let mut flash_size = None;
    for line in txt.lines() {
        let mut parts = line.splitn(2, ':');
        let key = parts.next()?.trim();
        let val = parts.next().map(str::trim)?;
        match key {
            "App start" => app_start = parse_hex_u32(val),
            "Flash size" => flash_size = parse_hex_u32(val),
            _ => {}
        }
    }
    match (app_start, flash_size) {
        (Some(app), Some(flash)) => Some((app, flash)),
        _ => None,
    }
}

fn candidate_info_paths() -> Vec<PathBuf> {
    let mut paths = Vec::new();

    if let Ok(p) = env::var("UF2_INFO_PATH") {
        paths.push(PathBuf::from(p));
    }

    // Common auto-mount roots on Linux; harmless if absent.
    if let Ok(user) = env::var("USER") {
        for root in ["/media", "/run/media"] {
            paths.push(PathBuf::from(root).join(&user).join("FTHR840BOOT/INFO_UF2.TXT"));
            paths.push(PathBuf::from(root).join(&user).join("FTHR840BOOT/INFO_UF2.TXT".to_lowercase()));
        }
    }

    paths
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=APP_BASE");
    println!("cargo:rerun-if-env-changed=FLASH_SIZE");
    println!("cargo:rerun-if-env-changed=RAM_BASE");
    println!("cargo:rerun-if-env-changed=RAM_SIZE");
    println!("cargo:rerun-if-env-changed=UF2_INFO_PATH");

    // Allow explicit overrides for flash layout.
    let env_app = env::var("APP_BASE").ok().and_then(|v| parse_hex_u32(&v));
    let env_flash = env::var("FLASH_SIZE").ok().and_then(|v| parse_hex_u32(&v));

    let from_info = candidate_info_paths()
        .iter()
        .find_map(|p| read_info_file(p).map(|vals| (vals, p.clone())));

    let ((app_start, flash_size), source) = match (env_app, env_flash, from_info) {
        (Some(app), Some(flash), _) => ((app, flash), "environment (APP_BASE/FLASH_SIZE)".to_string()),
        (None, None, Some(((app, flash), path))) => ((app, flash), format!("INFO_UF2.TXT at {}", path.display())),
        _ => {
            eprintln!(
                "Set APP_BASE and FLASH_SIZE from INFO_UF2.TXT (or UF2_INFO_PATH) before building.\n\
                 Example: APP_BASE=0x26000 FLASH_SIZE=0x100000 cargo build --release"
            );
            std::process::exit(1);
        }
    };

    if app_start >= flash_size {
        eprintln!(
            "APP_BASE ({:#x}) must be below FLASH_SIZE ({:#x}); check INFO_UF2.TXT.",
            app_start, flash_size
        );
        std::process::exit(1);
    }

    let ram_base = env::var("RAM_BASE")
        .ok()
        .and_then(|v| parse_hex_u32(&v))
        .unwrap_or(0x2000_0000);
    let ram_size = env::var("RAM_SIZE")
        .ok()
        .and_then(|v| parse_hex_u32(&v))
        .unwrap_or(0x0004_0000);

    let flash_len = flash_size - app_start;

    let memory_x = format!(
        "/* auto-generated by build.rs using {} */\n\
         MEMORY {{\n\
         FLASH : ORIGIN = {:#010x}, LENGTH = {:#010x}\n\
         RAM : ORIGIN = {:#010x}, LENGTH = {:#010x}\n\
         }}\n",
        source, app_start, flash_len, ram_base, ram_size
    );

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    let root_path = manifest_dir.join("memory.x");
    let out_path = out_dir.join("memory.x");

    fs::write(&root_path, &memory_x).expect("failed to write memory.x in crate root");
    fs::write(&out_path, &memory_x).expect("failed to write memory.x in OUT_DIR");

    println!("cargo:rustc-link-search={}", out_dir.display());
    println!("cargo:warning=feather-fw memory.x set from {}", source);
}
